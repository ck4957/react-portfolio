[
    {
        "id": "med-charting-sidebar",
        "slug": "med-charting-sidebar",
        "title": "Reducing Nurse Charting Time by 30% with a Simple Sidebar",
        "date": "Jan 2026",
        "readTime": "6 min read",
        "summary": "How we leveraged existing data to build a persistent sidebar that solved the medication scrolling problem‚Äîwithout waiting for backend changes.",
        "tags": [
            "Healthcare",
            "UX Design",
            "Frontend",
            "Product Development"
        ],
        "featured": true,
        "coverImage": null,
        "content": {
            "introduction": "Nurses using our iPad med charting app were spending 8 minutes per patient just managing the medication list. With 20-30+ medications to chart and only 2-3 visible at once, they were trapped in an endless scroll. The solution? A persistent sidebar that showed charting progress‚Äîbuilt within the same release using data we already had.",
            "sections": [
                {
                    "heading": "The Problem: Death by Scrolling",
                    "text": "Our initial design seemed logical: show all medication details in cards. But we quickly learned that nurses weren't just reading‚Äîthey were tracking progress. As they charted medications, those cards moved to the bottom of the list. To verify what they'd completed, they had to scroll down, losing sight of what still needed attention. This constant context-switching was exhausting and error-prone.",
                    "image": {
                        "src": "https://emrfinder.com/wp-content/uploads/2019/04/MatrixCare-EMR-Software-FlowSheets.webp",
                        "alt": "Example of a typical EMR medication flowsheet showing the complexity nurses navigate",
                        "caption": "Typical EMR flowsheet ‚Äî nurses must scroll through detailed medication information while tracking their progress"
                    }
                },
                {
                    "heading": "The Investigation",
                    "text": "I shadowed three nurses during their medication rounds. The pattern was clear: they'd chart a med, it would disappear from view, then they'd scroll down to verify it was recorded, lose track of the uncharted meds, scroll back up, and repeat. One nurse described it as 'playing hide-and-seek with medications.'"
                },
                {
                    "heading": "The Insight: We Already Had the Data",
                    "text": "Here's the key realization: the frontend already knew which medications were prepped and which were charted. We were tracking this state to sort the list and style the cards. We didn't need new APIs or backend changes‚Äîwe just needed to display this existing data differently."
                },
                {
                    "heading": "The Solution: Shopping Cart Pattern",
                    "text": "I pitched the solution using a familiar analogy: 'Think of it like a shopping cart on an e-commerce site. You can browse products in the main area, and your cart stays visible in the sidebar showing what you've added‚Äîno scrolling needed.' The sidebar would show: all prepped medications with minimal info (name, dose, time), visual confirmation of what's complete, and always visible, no matter what."
                },
                {
                    "heading": "Implementation: Same Release, Zero Backend Wait",
                    "text": "Because we were already managing the charting state in React, implementation was straightforward: extract prepped meds from existing state, create a collapsible sidebar component, show condensed medication summaries, and add show/hide toggle for nurses who wanted more screen space. Total development time: 3 days instead of the 3-week backend integration we initially estimated."
                },
                {
                    "heading": "The Results",
                    "list": [
                        "Average charting time dropped from 8 minutes to 5.5 minutes per patient (30% improvement)",
                        "Nurse satisfaction with charting workflow increased from 4.2/10 to 8.1/10",
                        "Zero reported instances of missed medications in the first month post-deployment",
                        "Feature was adopted by 95% of nurses within the first week"
                    ]
                },
                {
                    "heading": "Lessons Learned",
                    "list": [
                        "Don't wait for the 'perfect' backend solution when frontend data can solve 80% of the problem",
                        "Shadow users in their actual environment‚Äîthe scrolling issue wasn't obvious in our office testing",
                        "Familiar UI patterns (shopping cart) help stakeholders understand solutions faster",
                        "Small UX improvements can have outsized impact on critical workflows"
                    ]
                },
                {
                    "heading": "The Bigger Picture",
                    "text": "This wasn't about building a fancy feature‚Äîit was about solving a real workflow problem with the resources we already had. By leveraging existing frontend state instead of waiting for backend architecture changes, we shipped a meaningful improvement in days, not months. Sometimes the best solution is the one you can deploy tomorrow."
                }
            ]
        },
        "demoType": "interactive"
    },
    {
        "id": "chrome-extension-design-system",
        "slug": "chrome-extension-design-system",
        "title": "Building a Chrome Extension to Track Design System Adoption",
        "date": "Jan 2026",
        "readTime": "8 min read",
        "summary": "How we built a developer tool that scans web pages to detect and analyze design system components in real-time‚Äîwithout requiring any instrumentation in your application code.",
        "tags": [
            "Chrome Extension",
            "Design Systems",
            "DevTools",
            "Web Components"
        ],
        "featured": true,
        "coverImage": null,
        "content": {
            "introduction": "Your team has invested months building a comprehensive design system‚Äîcomponents, tokens, documentation, and all. But here's the hard question: How do you know if teams are actually using it? That's exactly why we built a Chrome extension to detect and analyze design system components on any web page.",
            "sections": [
                {
                    "heading": "The Challenge",
                    "text": "Sure, you can check npm download stats or scan repositories, but that only tells you if the package was installed, not if components are being used correctly in production. What you really need is real-time visibility into which components are live on which pages."
                },
                {
                    "heading": "Key Features",
                    "list": [
                        "üîç Automatic Component Discovery - Scans entire page including Shadow DOM",
                        "üìä Usage Analytics - Component counts, properties, and configurations",
                        "üéØ Visual Highlighting - Interactive component inspection",
                        "üëÅÔ∏è Deep Inspection - View properties, slots, and CSS Shadow Parts"
                    ]
                },
                {
                    "heading": "Technical Stack",
                    "text": "Built with Vite, React 19, TypeScript, Tailwind CSS v4, and CRXJS for modern Chrome extension development."
                },
                {
                    "heading": "Detection Strategies",
                    "list": [
                        "Custom Element Detection - Scan for elements with your tag prefix",
                        "Shadow DOM Traversal - Recursive scanning through encapsulated trees",
                        "Property Inspection - Introspect reactive properties from frameworks like Lit",
                        "Slot Analysis - Identify content projection patterns"
                    ]
                }
            ]
        },
        "demoType": "interactive"
    },
    {
        "id": "figma-code-connect",
        "slug": "figma-code-connect",
        "title": "Figma Code Connect: Bridging Design and Development",
        "date": "Dec 2025",
        "readTime": "5 min read",
        "summary": "A practical look at implementing Figma Code Connect to automate component code generation, with real-world results showing 60% faster handoffs and improved design consistency.",
        "tags": [
            "Figma",
            "Design Systems",
            "Developer Tools",
            "Component Libraries"
        ],
        "featured": false,
        "coverImage": null,
        "content": {
            "introduction": "Figma Code Connect acts as a bridge between your design system in Figma and your component library in code. When designers create components in Figma, developers can instantly see the exact code needed from your library‚Äîeliminating guesswork and reducing handoff friction.",
            "sections": [
                {
                    "heading": "The Design-to-Code Gap",
                    "text": "Before Code Connect, our workflow involved designers creating components in Figma, then developers manually translating those designs into code. This led to inconsistencies, with slight variations in spacing, colors, and states appearing across different pages. We were averaging 2-3 revision cycles per feature."
                },
                {
                    "heading": "How Code Connect Works",
                    "text": "Code Connect creates a mapping between Figma components and your React/Vue/Angular component library. When a developer inspects a button in Figma, they see the exact JSX or template code to use, complete with all the right props and variants."
                },
                {
                    "heading": "What Works Exceptionally Well",
                    "list": [
                        "Simple Components: Buttons, badges, tooltips, and icons get instant code generation with 60% faster handoffs",
                        "Consistency: Eliminates visual inconsistencies by ensuring developers use the exact component variants",
                        "Onboarding: New developers can quickly learn the component API by seeing usage examples directly in Figma",
                        "Documentation: Living examples that stay in sync with your actual component library"
                    ]
                },
                {
                    "heading": "Where Manual Work Still Matters",
                    "list": [
                        "Complex components like modals and multi-step forms need business logic that Code Connect can't provide",
                        "State management and event handlers must still be implemented by developers",
                        "Form validation, error handling, and conditional rendering require custom code",
                        "Integration with backend APIs and data fetching remains developer responsibility"
                    ]
                },
                {
                    "heading": "Real-World Impact",
                    "text": "After implementing Code Connect for 25 foundational components, we reduced design-to-development time by 8 hours per sprint. Visual inconsistencies dropped from 15 per release to just 3. Most importantly, developers reported higher confidence in implementation accuracy."
                }
            ]
        },
        "demoType": "interactive"
    }
]